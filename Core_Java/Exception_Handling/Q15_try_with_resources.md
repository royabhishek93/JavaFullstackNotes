# üéØ Q15: Try-with-Resources vs Try-Catch-Finally?

> **Interview Frequency:** 70% | **Difficulty:** ‚≠ê‚≠ê‚≠ê | **Study Time:** 3 minutes

---

## ü§î Problem

Understanding try-with-resources and when it's safer/cleaner than try-finally.

### Code Scenario
```java
// Try-finally (old approach)
BufferedReader reader = null;
try {
    reader = new BufferedReader(new FileReader("file.txt"));
    String line = reader.readLine();
} catch (IOException e) {
    // handle
} finally {
    if (reader != null) {
        try {
            reader.close();  // Can throw IOException!
        } catch (IOException e) {
            // handle close exception
        }
    }
}

// Try-with-resources (Java 7+)
try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"))) {
    String line = reader.readLine();
} catch (IOException e) {
    // handle
}  // reader automatically closed!
```

---

## üìå Why It Happens

**Try-with-resources:**
- Automatically calls `.close()` on AutoCloseable resources
- Handles exception suppression (close exceptions chained)
- Requires resource to implement AutoCloseable interface
- Cleaner, safer code with less boilerplate

**Try-finally:**
- Manual resource management
- Error-prone (forgetting close, double exceptions)
- Necessary before Java 7

---

## ‚ùå Wrong (Try-Finally Pitfalls)

```java
// WRONG: Exception during close is lost
OutputStream output = null;
try {
    output = new FileOutputStream("file.txt");
    output.write(data);
} finally {
    output.close();  // If write throws AND close throws, 
}                    // write exception is LOST!

// WRONG: Close never called if exception in assignment
BufferedReader reader = null;
try {
    reader = new BufferedReader(new FileReader("file.txt"));
    String line = reader.readLine();  // If this throws...
} finally {
    if (reader != null) {  // Check needed (defensive)
        reader.close();
    }
}

// WRONG: Multiple resources - nested try-finally mess
InputStream in = null;
OutputStream out = null;
try {
    in = new FileInputStream("input.txt");
    out = new FileOutputStream("output.txt");
    copy(in, out);
} finally {
    if (in != null) try { in.close(); } catch (IOException e) {}
    if (out != null) try { out.close(); } catch (IOException e) {}
}
```

---

## ‚úÖ Right (Try-with-Resources)

```java
// RIGHT: Single resource, automatic close
try (BufferedReader reader = new BufferedReader(
        new FileReader("file.txt"))) {
    String line = reader.readLine();
} catch (IOException e) {
    // Handle - close already called automatically
}

// RIGHT: Multiple resources
try (InputStream in = new FileInputStream("input.txt");
     OutputStream out = new FileOutputStream("output.txt")) {
    copy(in, out);
} catch (IOException e) {
    // Both in and out automatically closed in reverse order
}

// RIGHT: Custom AutoCloseable resource
class DatabaseConnection implements AutoCloseable {
    @Override
    public void close() throws Exception {
        // Cleanup code
    }
}

try (DatabaseConnection conn = new DatabaseConnection()) {
    conn.executeQuery("SELECT ...");
} catch (Exception e) {
    // Connection automatically closed
}

// RIGHT: Exception chaining in try-with-resources
try (var reader = new BufferedReader(new FileReader("file.txt"))) {
    String line = reader.readLine();
} catch (IOException e) {
    // If write AND close both throw:
    // write exception is PRIMARY
    // close exception is SUPPRESSED but accessible via getSuppressed()
}
```

---

## üí¨ Interview Tip (Say This Exactly)

"Use try-with-resources for any AutoCloseable resource. It automatically closes in reverse order, properly chains exceptions, and avoids boilerplate. Only use try-finally for non-AutoCloseable resources or cleanup without close."

---

## ‚òëÔ∏è Quick Checklist

- ‚úÖ Try-with-resources for ALL AutoCloseable (Stream, Reader, Connection, Handler)
- ‚úÖ Multiple resources separated by `;`
- ‚úÖ Resources closed in reverse order (LIFO)
- ‚úÖ Exceptions during close are suppressed (not lost)
- ‚úÖ Access suppressed exceptions: `e.getSuppressed()`
- ‚úÖ Can use `var` keyword: `try (var reader = ...)`
- ‚úÖ Try-finally only for non-closeable cleanup
- ‚úÖ No null checks needed (auto-generated by compiler)

---

## üìö Real Flipkart Scenario

```java
// Database query with proper resource management

// RIGHT: Try-with-resources for multiple resources
public List<Order> getOrdersByCustomer(long customerId) throws SQLException {
    try (Connection conn = dataSource.getConnection();
         PreparedStatement stmt = conn.prepareStatement(
             "SELECT * FROM orders WHERE customer_id = ?");
         ResultSet rs = stmt.executeQuery()) {
        
        stmt.setLong(1, customerId);
        rs.execute();
        
        List<Order> orders = new ArrayList<>();
        while (rs.next()) {
            orders.add(mapOrder(rs));
        }
        return orders;
    } catch (SQLException e) {
        logger.error("Query failed for customer: " + customerId, e);
        throw e;
    }
}
// All three resources (conn, stmt, rs) auto-closed in correct order!

// RIGHT: Stream resource (Java 8+)
public List<String> readLines(String path) {
    try (Stream<String> lines = Files.lines(Paths.get(path))) {
        return lines.filter(l -> !l.isEmpty())
                  .collect(Collectors.toList());
    } catch (IOException e) {
        throw new RuntimeException("Cannot read file", e);
    }
}

// RIGHT: Custom resource with exception handling
class CacheConnection implements AutoCloseable {
    private RedisClient redis;
    
    @Override
    public void close() throws IOException {
        if (redis != null) {
            redis.disconnect();  // Can throw IOException
        }
    }
}

try (CacheConnection cache = new CacheConnection()) {
    cache.set("key", "value");
} catch (IOException e) {
    // Even disconnect exception is handled
    logger.error("Cache error", e);
}
```

---

## ‚û°Ô∏è Bonus Follow-ups

1. **"What is AutoCloseable?"** ‚Üí Interface with `close()` method. Implemented by I/O classes.
2. **"Can you use try-with-resources without catch?"** ‚Üí Yes, `try (...) { }` is valid if you handle exception elsewhere
3. **"Are suppressed exceptions lost?"** ‚Üí No, accessible via `e.getSuppressed()`

---

## ‚ö†Ô∏è Common Pitfalls

**Pitfall 1: Forgetting resources are closed in reverse order**
```java
// ‚ùå Wrong assumption about order
try (FileOutputStream out = new FileOutputStream("log.txt");
     BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out))) {
    writer.write("test");
}
// Close order: writer first, then out (reverse of declaration)
// If you assume out closes first, buffered data might be lost!

// ‚úÖ Always flush before relying on close order
writer.flush();  // Ensure data written before close
```

**Pitfall 2: Ignoring suppressed exceptions**
```java
// ‚ùå Missing suppressed exception information
try (MyResource r = new MyResource()) {
    throw new IOException("Main exception");
} catch (IOException e) {
    log(e.getMessage());  // Only logs "Main exception"
    // Lost: close() exception if it also threw!
}

// ‚úÖ Check suppressed exceptions
catch (IOException e) {
    log(e.getMessage());
    for (Throwable suppressed : e.getSuppressed()) {
        log("Suppressed: " + suppressed.getMessage());
    }
}
```

**Pitfall 3: Null resources in try-with-resources**
```java
// ‚ùå NullPointerException if getResource() returns null!
try (Resource r = getResource()) {
    r.use();
}

// ‚úÖ Null check before try-with-resources
Resource r = getResource();
if (r == null) throw new IllegalStateException("Resource unavailable");
try (r) {
    r.use();
}
```

**Pitfall 4: Using try-with-resources for non-AutoCloseable**
```java
// ‚ùå Won't compile - Thread doesn't implement AutoCloseable
try (Thread t = new Thread(() -> { })) {
    t.start();
}

// ‚úÖ Manual cleanup for non-AutoCloseable
Thread t = new Thread(() -> { });
try {
    t.start();
} finally {
    t.interrupt();  // Manual cleanup
}
```

**Pitfall 5: Expensive operations in close()**
```java
// ‚ùå Slow close() blocks exception handling
class DatabaseConnection implements AutoCloseable {
    public void close() {
        database.flushAll();  // 5-second operation!
    }
}

// ‚úÖ Keep close() fast, do expensive cleanup explicitly
class DatabaseConnection implements AutoCloseable {
    public void flush() { database.flushAll(); }  // Explicit
    public void close() { database.disconnect(); }  // Fast
}

try (DatabaseConnection conn = ...) {
    conn.doWork();
    conn.flush();  // Explicit expensive operation BEFORE close
}
```

---

## üõë When NOT to Use Try-with-Resources

- ‚ùå When resource must stay open across methods (e.g., connection pools)
- ‚ùå For resources shared across threads (close on wrong thread!)
- ‚ùå When you need custom cleanup beyond close() (use finally)
- ‚úÖ DO use: Short-lived resources, file/network operations, JDBC queries

---

## üîó Related Questions

- **Q13:** Checked vs Unchecked (IOException handling)
- **Q14:** Custom Exceptions (creating AutoCloseable resources)
- **Q49:** Testing async code (resource cleanup in tests)

---

**Last Updated:** February 22, 2026  
**Next: [Q16_exception_async.md](Q16_exception_async.md)**
